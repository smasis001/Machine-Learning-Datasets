"""Common Utility Functions"""
# pylint: disable=E1101,W0212,C0302,C0103,C0415,C0121
from typing import Protocol, Any, Tuple, Union, Optional
import os
import sys
import subprocess
import pandas as pd
import numpy as np
from matplotlib.figure import Figure
from scipy.sparse import csr_matrix, csc_matrix
import torchvision

ArrayLike = Union[list, tuple, np.ndarray, pd.Series,\
                  pd.DataFrame, csr_matrix, csc_matrix]
Tensor = torchvision.utils.torch.Tensor

class BaseModelProtocol(Protocol):
    """Protocol for Any Sklearn Compatible Models"""
    def predict(self, X:ArrayLike, **kwargs:Any) -> Any:
        """Predict with the fitted model"""

class BaseTransformerProtocol(Protocol):
    """Protocol for Any Sklearn Compatible Scalers, Encoders & Transformers"""
    def transform(self, X:ArrayLike, **kwargs:Any) -> Any:
        """Transform with the fitted transformer"""

    def inverse_transform(self, X:ArrayLike, **kwargs:Any) -> Any:
        """Inverse transform with the fitted transformer"""

class BaseAIF360DSProtocol(Protocol):
    """Protocol for AIF360 Datasets"""
    def validate_dataset(self) -> Any:
        """Validate the AIF360 dataset"""

class BaseAIF360MetricProtocol(Protocol):
    """Protocol for AIF360 Metrics"""
    def num_instances(self, privileged:Optional[bool]=None) -> int:
        """Count the number of priviledged instances"""

class BaseAlibiExplanationProtocol(Protocol):
    """Protocol for Alibi Explanations"""
    def to_json(self) -> str:
        """Convert the Alibi explanation to JSON format"""

def runcmd(
        cmd:str,
        verbose:Optional[bool] = False
    ) -> Tuple[bool, str, int]:
    """Runs a command in the shell and captures the output.

    Args:
        cmd (str): The command to be executed.
        verbose (bool, optional): If True, the output will be printed to the console.
                                  Defaults to False.

    Returns:
        Tuple[bool, str, int]: A tuple containing the following elements:
            - error (bool): True if an error occurred during the execution of the command,
                            False otherwise.
            - output (str): The output generated by the command.
            - numlines (int): The number of lines in the output.
    """
    sproc = subprocess.Popen(cmd, shell=True, stdin=subprocess.PIPE,
                             stdout=subprocess.PIPE, stderr=subprocess.PIPE, )
    output = ''
    numlines = 0
    error = True
    while True:
        if error is True:
            line = sproc.stderr.readline().decode("utf-8")
            if line == '' and (sproc.poll() is None or sproc.poll() == 0):
                error = False
        if error is False:
            line = sproc.stdout.readline().decode("utf-8")
        if line == '' and sproc.poll() is not None:
            break
        if verbose:
            sys.stdout.write(line)
            sys.stdout.flush()
        output = output + line
        numlines = numlines + 1

    return error, output.strip(), numlines

def plot_polar(
        df:pd.DataFrame,
        r:Union[str, int, ArrayLike],
        theta:Union[str, int, ArrayLike],
        name:Optional[str] = None,
        show:Optional[bool] = True
    ) -> Optional[Figure]:
    """Plots a polar line chart using Plotly Express.

    Args:
        df (pd.DataFrame): The DataFrame containing the data.
        r (Union[str, int, ArrayLike]): The column name or index of the radial coordinate.
        theta (Union[str, int, ArrayLike]): The column name or index of the angular coordinate.
        name (Optional[str], optional): The title of the chart. Defaults to None.
        show (Optional[bool], optional): Whether to display the chart. Defaults to True.

    Returns:
        Optional[Figure]: The Plotly Figure object if show is False, otherwise None.

    Raises:
        ModuleNotFoundError: If `plotly` or `kaleido` is not installed.

    Example:
        plot_polar(df, 'r', 'theta', name='Polar Chart', show=True)
    """
    try:
        import plotly.express as px
    except ModuleNotFoundError as exc:
        raise ModuleNotFoundError("`plotly` must be installed to execute this function") from exc
    fig = px.line_polar(df, r=r, theta=theta, line_close=True, title=name)
    fig.update_traces(fill='toself')

    if show:
        try:
            import kaleido
        except ModuleNotFoundError as exc:
            raise ModuleNotFoundError("`kaleido` must be installed to execute "
                                      "this function") from exc
        if name is None:
            name = 'default'

        name = name.lower()
        cwd = os.getcwd()
        img_path = os.path.join(cwd, f"{name}.png")
        fig.write_image(img_path)
        show_image(img_path, width=800)
    else:
        return fig

def show_image(
        path_to_image:str,
        width:Optional[int] = None,
        height:Optional[int] = None
    ) -> None:
    """Displays an image in Jupyter Notebook.

    Args:
        path_to_image (str): The path to the image file.
        width (Optional[int]): The width of the displayed image. Defaults to None.
        height (Optional[int]): The height of the displayed image. Defaults to None.

    Raises:
        ModuleNotFoundError: If `ipython` module is not installed.

    Raises:
        ValueError: If the extension of the image file is unknown.

    Returns:
        None

    Example:
        show_image('path/to/image.jpg', width=500, height=300)
    """
    try:
        from IPython.display import display, HTML #Image,
        from base64 import b64encode
    except ModuleNotFoundError as exc:
        raise ModuleNotFoundError("`ipython` must be installed to execute this function") from exc

    mime_type = None

    # More MIME types:
    # https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types
    if path_to_image.endswith('.jpg') or path_to_image.endswith('.jpeg'):
        mime_type = 'image/jpeg'
    elif path_to_image.endswith('.png'):
        mime_type = 'image/png'
    elif path_to_image.endswith('.gif'):
        mime_type = 'image/gif'
    else:
        raise ValueError(f'Unknown extension: {path_to_image}')

    img = open(path_to_image, 'rb').read()
    data_url = f'data:{mime_type};base64,' + b64encode(img).decode()

    width_str = f"width='{width:d}'" if width is not None else ''
    height_str = f"height='{height:d}'" if height is not None else ''

    display(HTML(f"<img src='{data_url}' {width_str}{height_str}>"))
